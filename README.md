# Album Manager CLI

Welcome to Album Manager CLI 🎉

This project offers a sleek set of scripts to manage and organize your photo albums stored locally. Whether you need to split folders of images into organized albums by date, or you’re just tired of scrolling aimlessly through chaotic directories — Album Manager CLI is here to save the day.

---

## 📚 Table of Contents
1. [Motivation](#-motivation)
2. [Project Setup](#️-project-setup)
3. [Scripts Currently Developed](#-scripts-currently-developed)
    - [Group Assets - Non Interactive](#groups-assets---non-interactive)
    - [Analyze Manifest - Non Interactive](#analyze-manifest---non-interactive)
4. [Continuous Integration / Development](
  #-continuous-integration--development)

---

## 🚀 Motivation
Managing photo albums can be a hassle. Do you have images dumped into one folder, named cryptically as IMG_XXXX.jpg with no rhyme or reason? You’re not alone. Album Manager CLI was created to tame that chaos—making it effortless to sort photos into albums using dates, while also letting you name albums on the go.  
Goodbye, photo mess; hello, organized bliss!

## 🛠️ Project Setup
Ready to get started? Here’s how you can set up Album Manager CLI on your local machine.  
Follow these steps to get everything up and running:

1. Clone the Repository  
  Start by cloning this repository to your local system using git.

  ```bash
  git clone https://github.com/your-username/album-manager-cli.git
  cd album-manager-cli
  ```

2. Ensure Python 3.8 is Installed  
  Make sure you have Python 3.8 installed. If not, you can grab it from [python.org]().

3. Install Poetry  
  Poetry is used for managing dependencies and environments. You can install Poetry via the official installer:

  ```bash
  curl -sSL https://install.python-poetry.org | python3 -
  ```

  Alternatively, refer to the [Poetry Documentation](https://python-poetry.org/docs/) for platform-specific instructions.

4. Install Project Dependencies  
  Use Poetry to install all dependencies specified in the pyproject.toml file:

  ```bash
  poetry install
  ```

  This will create a virtual environment and install all the necessary packages for you to run and develop the Album Manager CLI.

## 📜 Scripts Currently Developed
The following section describes the various scripts which have been developed so far.  
In the future we expect for further scripts to be developed as needs arise.


### Groups Assets - Non Interactive

A command-line Python script to recursively organize images and videos from a source directory into date-based albums in a destination folder. It preserves the original media and logs a detailed manifest of all operations performed.

#### What it Does?
This script automates the task of organizing your media files by grouping images and videos based on their metadata dates (e.g., EXIF date for photos or file creation date for videos), and copying them into folders named after those dates.  
This is especially useful for organizing large photo or video dumps, like those exported from phones or cloud storage.

##### Key Features
- 📂 **Recursive Scan**: Searches through all subdirectories for media files.
- 🖼️ **Image & Video Support**: Handles both photos and videos.
- 📅 **Date Grouping**: Automatically sorts files into folders based on their date.
- 📋 **Manifest Generation**: Outputs a manifest.json file with a detailed log of the copied files.
- ✅ **Non-destructive**: Does not modify or remove the original files.
- 📊 **Progress Tracking**: Uses tqdm for clean progress bars in the terminal.
- 🪵 **Colorful Logging**: Logs steps and debug info using loguru.

#### Usage Example
```bash
python -m src.entrypoints.group_assets_non_interactive .\test-data\ .\test-data-grouped\    
```

#### Output Example
- **Folder structure** with the various assets **organized**:
  ```
  2023-08-14/
      IMG_001.jpg
      VID_001.mp4
  2023-08-15/
      IMG_002.jpg
  manifest.json
  ```
- A structured **log of all file transfers**, for auditing or rollback purposes: `manifest.json`

### Analyze Manifest - Non-Interactive

A command-line Python script that reads a manifest file and verifies whether all the file copy operations it describes were successfully completed.  
It checks if each destination file is identical to its corresponding source file.

#### What it Does?
This script is designed to validate the integrity of a previously executed file-copy operation, such as one carried out by a media-organizing script like **Group Assets - Non-Interactive**.

It takes a `manifest.json` file as input (containing paths for source and destination files) and compares each pair to detect any discrepancies—ensuring the destination files were copied correctly and match the original ones bit-for-bit.

##### Key Features
- 🧾 **Manifest Analysis**: Reads and processes manifest.json files generated by asset-organizing scripts.
- 🧪 **File Comparison**: Verifies each file pair using a byte-level comparison.
- ❗ **Discrepancy Detection**: Logs any mismatched files with clear source/destination paths.
- 📊 **Progress Tracking**: Uses tqdm to show progress bars while processing.
- 🪵 **Colorful Logging**: Uses loguru for readable, leveled logging in the terminal.

#### Usage Example
```bash
python -m src.entrypoints.analyze_non_interactive ./test-data-grouped/manifest.json
```

#### Output Example
If discrepancies are found:
```
[   ERROR   ] 	File with discrepancies found:
[   ERROR   ] 	- source: /original/path/image1.jpg
[   ERROR   ] 	- destination: /organized/path/image1
```

## 🔧 Continuous Integration / Development

### Code Quality Validation
This project ensures high code quality and adherence to best practices using:
- Ruff for linting 🧹
- Mypy for static type checking 🧐

On every push to the main branch, automated checks run to validate code quality, catching errors before they become problems. This keeps the project clean, maintainable, and less likely to break your heart (or codebase).

